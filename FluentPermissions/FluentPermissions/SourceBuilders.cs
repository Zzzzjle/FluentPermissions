using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace FluentPermissions;

internal static class SourceBuilders
{
    public static string BuildModels(Model model)
    {
        var ns = GetRootNamespace(model.Compilation);
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine($"namespace {ns}.Generated;");
        sb.AppendLine();
        sb.AppendLine("internal static class PermissionModels");
        sb.AppendLine("{");
        // Group model
        sb.AppendLine("    internal sealed class PermissionGroupInfo");
        sb.AppendLine("    {");
        sb.AppendLine("        public string Key { get; }");
        sb.AppendLine("        public string? ParentKey { get; }");
        sb.AppendLine("        public string LogicalName { get; }");
        sb.AppendLine("        public string DisplayName { get; }");
        sb.AppendLine("        public string Description { get; }");
        // emit strong-typed group option properties
        foreach (var prop in model.GroupOptionProps)
        {
            var type = prop.Kind switch
            {
                ConstKind.Bool => "bool",
                ConstKind.Int => "int",
                ConstKind.Double => "double",
                ConstKind.String => "string?",
                _ => "object?"
            };
            sb.AppendLine($"        public {type} {prop.Name} {{ get; }}");
        }

        sb.AppendLine(
            "        public global::System.Collections.Generic.IReadOnlyList<PermissionGroupInfo> SubGroups { get; }");
        sb.AppendLine(
            "        public global::System.Collections.Generic.IReadOnlyList<PermissionItemInfo> Permissions { get; }");
        sb.AppendLine(
            "        public PermissionGroupInfo(string key, string logicalName, string displayName, string description,");
        sb.AppendLine("            string? parentKey,");
        // constructor params for group option props
        foreach (var prop in model.GroupOptionProps)
        {
            var type = prop.Kind switch
            {
                ConstKind.Bool => "bool",
                ConstKind.Int => "int",
                ConstKind.Double => "double",
                ConstKind.String => "string?",
                _ => "object?"
            };
            sb.AppendLine($"            {type} {prop.Name.ToLowerInvariant()},");
        }

        sb.AppendLine("            global::System.Collections.Generic.IReadOnlyList<PermissionGroupInfo> subGroups,");
        sb.AppendLine("            global::System.Collections.Generic.IReadOnlyList<PermissionItemInfo> permissions)");
        sb.AppendLine("        {");
        sb.AppendLine(
            "            Key = key; ParentKey = parentKey; LogicalName = logicalName; DisplayName = displayName; Description = description;");
        foreach (var prop in model.GroupOptionProps)
            sb.AppendLine($"            {prop.Name} = {prop.Name.ToLowerInvariant()};");

        sb.AppendLine("            SubGroups = subGroups; Permissions = permissions;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        // Item model
        sb.AppendLine("    internal sealed class PermissionItemInfo");
        sb.AppendLine("    {");
        sb.AppendLine("        public string Key { get; }");
        sb.AppendLine("        public string LogicalName { get; }");
        sb.AppendLine("        public string DisplayName { get; }");
        sb.AppendLine("        public string Description { get; }");
        // emit strong-typed permission option properties
        foreach (var prop in model.PermOptionProps)
        {
            var type = prop.Kind switch
            {
                ConstKind.Bool => "bool",
                ConstKind.Int => "int",
                ConstKind.Double => "double",
                ConstKind.String => "string?",
                _ => "object?"
            };
            sb.AppendLine($"        public {type} {prop.Name} {{ get; }}");
        }

        sb.AppendLine("        public string GroupKey { get; }");
        sb.AppendLine(
            "        public PermissionItemInfo(string key, string logicalName, string displayName, string description,");
        // constructor params for permission option props
        foreach (var prop in model.PermOptionProps)
        {
            var type = prop.Kind switch
            {
                ConstKind.Bool => "bool",
                ConstKind.Int => "int",
                ConstKind.Double => "double",
                ConstKind.String => "string?",
                _ => "object?"
            };
            sb.AppendLine($"            {type} {prop.Name.ToLowerInvariant()},");
        }

        sb.AppendLine("            string groupKey)");
        sb.AppendLine("        {");
        sb.AppendLine(
            "            Key = key; LogicalName = logicalName; DisplayName = displayName; Description = description; GroupKey = groupKey;");
        foreach (var prop in model.PermOptionProps)
            sb.AppendLine($"            {prop.Name} = {prop.Name.ToLowerInvariant()};");

        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("}");
        return sb.ToString();
    }

    public static string BuildApp(Model model)
    {
        var ns = GetRootNamespace(model.Compilation);
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine($"namespace {ns}.Generated;");
        sb.AppendLine();
        sb.AppendLine("internal static class AppPermissions");
        sb.AppendLine("{");
        sb.AppendLine(
            "    private static readonly global::System.Collections.Generic.IReadOnlyList<PermissionModels.PermissionGroupInfo> _all;");
        sb.AppendLine("    static AppPermissions()");
        sb.AppendLine("    {");
        var rootVars = new List<string>();
        foreach (var g in model.RootGroups)
        {
            var v = EmitCtorGroup(sb, g, null, 8);
            rootVars.Add(v);
        }

        sb.AppendLine(rootVars.Count == 0
            ? "        _all = global::System.Array.Empty<PermissionModels.PermissionGroupInfo>();"
            : $"        _all = new PermissionModels.PermissionGroupInfo[] {{ {string.Join(", ", rootVars)} }};");

        sb.AppendLine("        GroupsByKey = BuildGroupsByKey();");
        sb.AppendLine("        PermsByKey = BuildPermsByKey();");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine(
            "    public static global::System.Collections.Generic.IReadOnlyList<PermissionModels.PermissionGroupInfo> GetAllGroups()");
        sb.AppendLine("    {");
        sb.AppendLine("        return _all;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine(
            "    public static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, PermissionModels.PermissionGroupInfo> GroupsByKey;");
        sb.AppendLine(
            "    public static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, PermissionModels.PermissionItemInfo> PermsByKey;");
        sb.AppendLine();
        sb.AppendLine(
            "    private static global::System.Collections.Generic.IReadOnlyDictionary<string, PermissionModels.PermissionGroupInfo> BuildGroupsByKey()");
        sb.AppendLine("    {");
        sb.AppendLine(
            "        var dict = new global::System.Collections.Generic.Dictionary<string, PermissionModels.PermissionGroupInfo>(global::System.StringComparer.Ordinal);");
        sb.AppendLine("        foreach (var r in GetAllGroups()) AddGroup(r);");
        sb.AppendLine(
            "        return new global::System.Collections.ObjectModel.ReadOnlyDictionary<string, PermissionModels.PermissionGroupInfo>(dict);");
        sb.AppendLine();
        sb.AppendLine("        void AddGroup(PermissionModels.PermissionGroupInfo g)");
        sb.AppendLine("        {");
        sb.AppendLine("            dict[g.Key] = g;");
        sb.AppendLine("            foreach (var c in g.SubGroups) AddGroup(c);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine(
            "    private static global::System.Collections.Generic.IReadOnlyDictionary<string, PermissionModels.PermissionItemInfo> BuildPermsByKey()");
        sb.AppendLine("    {");
        sb.AppendLine(
            "        var dict = new global::System.Collections.Generic.Dictionary<string, PermissionModels.PermissionItemInfo>(global::System.StringComparer.Ordinal);");
        sb.AppendLine("        foreach (var r in GetAllGroups()) AddPerms(r);");
        sb.AppendLine(
            "        return new global::System.Collections.ObjectModel.ReadOnlyDictionary<string, PermissionModels.PermissionItemInfo>(dict);");
        sb.AppendLine();
        sb.AppendLine("        void AddPerms(PermissionModels.PermissionGroupInfo g)");
        sb.AppendLine("        {");
        sb.AppendLine("            foreach (var p in g.Permissions) dict[p.Key] = p;");
        sb.AppendLine("            foreach (var c in g.SubGroups) AddPerms(c);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        // Keys constants
        sb.AppendLine("    public static class Keys");
        sb.AppendLine("    {");
        foreach (var g in model.RootGroups) EmitKeysForGroup(sb, g, null, 8);

        sb.AppendLine("    }");
        sb.AppendLine();
        // Hierarchy
        foreach (var g in model.RootGroups) EmitGroupClass(sb, g, null, 4);

        sb.AppendLine("}");
        return sb.ToString();

        string EmitCtorGroup(StringBuilder esb, GroupDef g, string? parentKey, int indent)
        {
            var key = parentKey is null ? g.LogicalName : parentKey + "_" + g.LogicalName;
            var pad = new string(' ', indent);
            // emit children first
            var childVarNames = new List<string>();
            foreach (var c in g.Children)
            {
                var cv = EmitCtorGroup(esb, c, key, indent);
                childVarNames.Add(cv);
            }

            // build children array
            var childrenVar = SafeIdent("children_" + key);
            if (childVarNames.Count == 0)
                esb.AppendLine(pad +
                               $"var {childrenVar} = global::System.Array.Empty<PermissionModels.PermissionGroupInfo>();");
            else
                esb.AppendLine(pad +
                               $"var {childrenVar} = new PermissionModels.PermissionGroupInfo[] {{ {string.Join(", ", childVarNames)} }};");

            // build permissions array
            var permsVar = SafeIdent("perms_" + key);
            if (g.Permissions.Count == 0)
            {
                esb.AppendLine(pad +
                               $"var {permsVar} = global::System.Array.Empty<PermissionModels.PermissionItemInfo>();");
            }
            else
            {
                var permItems = new StringBuilder();
                var first = true;
                foreach (var p in g.Permissions)
                {
                    if (!first) permItems.Append(", ");
                    first = false;
                    var pArgs = new StringBuilder();
                    var pDisplay = p.DisplayName is null ? $"\"{p.LogicalName}\"" : ToLiteral(p.DisplayName);
                    var pDesc = p.Description is null ? "string.Empty" : ToLiteral(p.Description);
                    pArgs.Append(
                        $"\"{key}_{p.LogicalName}\", \"{p.LogicalName}\", {pDisplay}, {pDesc}");
                    foreach (var prop in model.PermOptionProps)
                    {
                        var has = p.Props.TryGetValue(prop.Name, out var val);
                        var lit = has
                            ? val!.ToEmitLiteral()
                            : prop.Kind == ConstKind.String
                                ? "null"
                                : prop.Kind == ConstKind.Bool
                                    ? "false"
                                    : "0";
                        pArgs.Append(", ").Append(lit);
                    }

                    pArgs.Append(", \"" + key + "\"");
                    permItems.Append($"new PermissionModels.PermissionItemInfo({pArgs})");
                }

                esb.AppendLine(pad + $"var {permsVar} = new PermissionModels.PermissionItemInfo[] {{ {permItems} }};");
            }

            // emit group with typed options and readonly children/perms
            var gArgs = new StringBuilder();
            var gDisplay = g.DisplayName is null ? $"\"{g.LogicalName}\"" : ToLiteral(g.DisplayName);
            var gDesc = g.Description is null ? "string.Empty" : ToLiteral(g.Description);
            gArgs.Append(
                $"\"{key}\", \"{g.LogicalName}\", {gDisplay}, {gDesc}, {(parentKey is null ? "null" : $"\"{parentKey}\"")}");
            foreach (var prop in model.GroupOptionProps)
            {
                var has = g.Props.TryGetValue(prop.Name, out var val);
                var lit = has
                    ? val!.ToEmitLiteral()
                    : prop.Kind == ConstKind.String
                        ? "null"
                        : prop.Kind == ConstKind.Bool
                            ? "false"
                            : "0";
                gArgs.Append(", ").Append(lit);
            }

            var groupVar = SafeIdent("group_" + key);
            esb.AppendLine(pad +
                           $"var {groupVar} = new PermissionModels.PermissionGroupInfo({gArgs}, {childrenVar}, {permsVar});");
            return groupVar;
        }

        void EmitKeysForGroup(StringBuilder esb, GroupDef g, string? parentKey, int indent)
        {
            var key = parentKey is null ? g.LogicalName : parentKey + "_" + g.LogicalName;
            var pad = new string(' ', indent);
            esb.AppendLine(pad + $"public const string {SafeIdent(key)} = \"{key}\";");
            foreach (var p in g.Permissions)
                esb.AppendLine(pad +
                               $"public const string {SafeIdent(key + "_" + p.LogicalName)} = \"{key}_{p.LogicalName}\";");
            foreach (var c in g.Children)
                EmitKeysForGroup(esb, c, key, indent);
        }

        void EmitGroupClass(StringBuilder esb, GroupDef g, string? parentKey, int indent)
        {
            var key = parentKey is null ? g.LogicalName : parentKey + "_" + g.LogicalName;
            var pad = new string(' ', indent);
            esb.AppendLine(pad + $"public static class {SafeIdent(g.LogicalName)}");
            esb.AppendLine(pad + "{");
            esb.AppendLine(pad +
                           $"    public static readonly PermissionModels.PermissionGroupInfo Group = GroupsByKey[\"{key}\"]; ");
            foreach (var p in g.Permissions)
                esb.AppendLine(pad +
                               $"    public static readonly PermissionModels.PermissionItemInfo {SafeIdent(p.LogicalName)} = PermsByKey[\"{key}_{p.LogicalName}\"]; ");
            foreach (var c in g.Children)
                EmitGroupClass(esb, c, key, indent + 4);
            esb.AppendLine(pad + "}");
        }
    }

    private static string ToLiteral(string s)
    {
        return "\"" + PermissionSourceGenerator.EscapeString(s) + "\"";
    }

    private static string GetRootNamespace(Compilation compilation)
    {
        var asm = compilation.AssemblyName ?? "FluentPermissions";
        var valid = new string(asm.Where(ch => char.IsLetterOrDigit(ch) || ch == '_' || ch == '.').ToArray());
        if (string.IsNullOrWhiteSpace(valid)) valid = "FluentPermissions";
        return valid;
    }

    private static string SafeIdent(string name)
    {
        var sb = new StringBuilder(name.Length);
        foreach (var ch in name)
            sb.Append(char.IsLetterOrDigit(ch) || ch == '_' ? ch : '_');
        if (sb.Length == 0 || (!char.IsLetter(sb[0]) && sb[0] != '_')) sb.Insert(0, '_');
        return sb.ToString();
    }
}